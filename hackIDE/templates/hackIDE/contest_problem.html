{% extends 'hackIDE/base.html' %}
{% load static %}

{% block title %}{{ problem.title }} - {{ contest.title }}{% endblock %}

{% block extra_css %}
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.12/ace.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
<style>
.problem-container {
    background: white;
    border-radius: 10px;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    margin-bottom: 2rem;
}

.problem-header {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: 1.5rem;
    border-radius: 10px 10px 0 0;
    position: relative;
    overflow: hidden;
}

.problem-meta {
    display: flex;
    gap: 15px;
    margin-top: 1rem;
}

.meta-item {
    background: rgba(255,255,255,0.2);
    padding: 5px 12px;
    border-radius: 20px;
    font-size: 0.9rem;
}

/* Bottom-right badges container */
.badges-br {
    position: absolute;
    right: 12px;
    bottom: 12px;
    gap: 8px;
    display: flex;
    align-items: center;
}

.company-badge {
    background: #0d6efd;
    color: #fff;
    border-radius: 999px;
    padding: 6px 10px;
    font-size: 0.75rem;
    font-weight: 700;
    letter-spacing: .03em;
    white-space: nowrap;
}

.difficulty-badge {
    padding: 6px 10px;
    border-radius: 999px;
    font-size: 0.75rem;
    font-weight: 700;
    letter-spacing: .03em;
    color: #fff;
    white-space: nowrap;
}

/* Color mapping */
.difficulty-badge.easy { background-color: #28a745; }
.difficulty-badge.medium { background-color: #ffc107; color: #212529; }
.difficulty-badge.hard { background-color: #dc3545; }

.editor-container {
    padding: 1.5rem;
}

#editor {
    height: 400px;
    border: 1px solid #ddd;
    border-radius: 5px;
}

.controls {
    margin-top: 1rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.test-cases {
    background: #f8f9fa;
    padding: 1.5rem;
    border-radius: 0 0 10px 10px;
}

.test-case {
    background: white;
    padding: 1rem;
    margin: 0.5rem 0;
    border-radius: 5px;
    border-left: 4px solid #007bff;
}

.submission-result {
    margin-top: 1rem;
    padding: 1rem;
    border-radius: 5px;
    display: none;
}

.submission-result.success {
    background-color: #d4edda;
    border: 1px solid #c3e6cb;
    color: #155724;
}

.submission-result.error {
    background-color: #f8d7da;
    border: 1px solid #f5c6cb;
    color: #721c24;
}

/* Action buttons styling */
.action-buttons {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
    align-items: flex-start;
}

.action-buttons .btn {
    margin-right: 0;
    position: relative;
    transition: all 0.3s ease;
}

.action-buttons .btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.15);
}

#test-code {
    background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
    border: none;
    color: white;
}

#test-code:hover {
    background: linear-gradient(135deg, #5a6268 0%, #343a40 100%);
}

#submit-solution {
    background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
    border: none;
}

#submit-solution:hover {
    background: linear-gradient(135deg, #218838 0%, #17a2b8 100%);
}

.final-submission-info {
    background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
    color: white;
    padding: 12px;
    border-radius: 8px;
    margin-top: 1rem;
    border-left: 4px solid #721c24;
}

.final-submission-info h6 {
    margin-bottom: 8px;
    font-weight: bold;
}

.modal-header.bg-danger {
    background: linear-gradient(135deg, #dc3545 0%, #c82333 100%) !important;
}

/* Proctoring Warning Banner */
.proctoring-banner {
    background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
    color: white;
    padding: 15px;
    border-radius: 8px;
    margin-bottom: 20px;
    text-align: center;
    font-weight: 500;
    box-shadow: 0 2px 10px rgba(238, 90, 36, 0.3);
}

.proctoring-banner .banner-icon {
    font-size: 1.2em;
    margin-right: 8px;
}

/* Back Navigation Button */
.back-navigation {
    margin-bottom: 15px;
}

.back-navigation .btn {
    transition: all 0.3s ease;
    border-color: #6c757d;
    color: #6c757d;
}

.back-navigation .btn:hover {
    background-color: #6c757d;
    border-color: #6c757d;
    color: white;
    transform: translateX(-2px);
}

.back-navigation .btn i {
    margin-right: 8px;
    transition: transform 0.3s ease;
}

.back-navigation .btn:hover i {
    transform: translateX(-3px);
}
</style>
{% endblock %}

{% block content %}
{% csrf_token %}
<div class="container-fluid">
    <div class="row">
        <div class="col-md-12">
            <!-- Practice Mode Banner -->
            {% if is_practice_mode %}
            <div class="proctoring-banner" style="background: linear-gradient(135deg, #17a2b8 0%, #138496 100%);">
                <span class="banner-icon">üéØ</span>
                <strong>Practice Mode:</strong> {{ practice_message }}
                No camera monitoring required.
            </div>
            {% elif require_proctor %}
            <!-- Proctoring Warning Banner -->
            <div class="proctoring-banner">
                <span class="banner-icon">üìπ</span>
                <strong>Camera Monitoring Active:</strong> Your camera continues monitoring you throughout this contest. 
                Face must remain visible at all times.
                <button id="manual-start-proctoring" class="btn btn-sm btn-light ms-3" style="display: none;">Start Camera Manually</button>
            </div>
            {% elif proctoring_skip_reason %}
            <!-- Contest Status Banner -->
            <div class="proctoring-banner" style="background: linear-gradient(135deg, #6c757d 0%, #495057 100%);">
                <span class="banner-icon">‚ÑπÔ∏è</span>
                <strong>Contest Status:</strong> {{ proctoring_skip_reason }}. 
                {% if "not currently active" in proctoring_skip_reason %}
                You can view problems but cannot submit solutions.
                {% endif %}
            </div>
            {% endif %}
            
            <!-- Back Button with Camera Preservation -->
            <div class="back-navigation mb-3">
                <button id="back-to-contest" class="btn btn-outline-secondary" onclick="navigateBackToContest(event)">
                    <i class="fas fa-arrow-left"></i> Back to Problems
                </button>
            </div>
            
            <nav aria-label="breadcrumb">
                <ol class="breadcrumb">
                    <li class="breadcrumb-item"><a href="{% url 'hackIDE:contest_list' %}">Contests</a></li>
                    <li class="breadcrumb-item"><a href="{% url 'hackIDE:contest_detail' contest.id %}" onclick="preserveCameraForNavigation(event, this.href)">{{ contest.title }}</a></li>
                    <li class="breadcrumb-item active">{{ problem.title }}</li>
                </ol>
            </nav>
            
            <div class="problem-container">
                <div class="problem-header">
                    <h2>{{ problem.title }}</h2>
                    <p class="mb-0">{{ problem.description }}</p>
                    
                    <div class="problem-meta">
                        <span class="meta-item">
                            <strong>Difficulty:</strong> {{ problem.difficulty }}
                        </span>
                        <span class="meta-item">
                            <strong>Points:</strong> {{ problem.points }}
                        </span>
                        <span class="meta-item">
                            <strong>Time Limit:</strong> {{ problem.time_limit }}ms
                        </span>
                        <span class="meta-item">
                            <strong>Memory Limit:</strong> {{ problem.memory_limit }}MB
                        </span>
                    </div>

                    <div class="badges-br">
                        {% if problem.company_tag %}
                        <span class="company-badge">{{ problem.company_tag }}</span>
                        {% endif %}
                        <span class="difficulty-badge {{ problem.difficulty|lower }} text-uppercase">{{ problem.difficulty }}</span>
                    </div>
                </div>
                
                <div class="editor-container">
                    <h5>Your Solution</h5>
                    <div id="editor">{{ problem.get_boilerplate_code|default:"" }}</div>
                    
                    <div class="controls">
                        <div class="language-selector">
                            <label for="language">Language:</label>
                            <select id="language" class="form-select form-select-sm" style="width: auto; display: inline-block; margin-left: 10px;">
                                <option value="PYTHON">Python</option>
                                <option value="JAVA">Java</option>
                                <option value="CPP">C++</option>
                                <option value="JAVASCRIPT">JavaScript</option>
                                <option value="C">C</option>
                            </select>
                        </div>
                        
                        <div class="action-buttons">
                            <button id="test-code" class="btn btn-outline-primary">üß™ Test Code</button>
                            <button id="submit-solution" class="btn btn-success">üöÄ Submit Solution</button>
                        </div>
                    </div>
                    
                    <div id="submission-result" class="submission-result"></div>
                </div>
                
                <div class="test-cases">
                    <h5>Test Cases</h5>
                    {% for test_case in parsed_test_cases %}
                    <div class="test-case">
                        <div class="row">
                            <div class="col-md-6">
                                <strong>Input:</strong>
                                <pre>{{ test_case.input|default:"No input" }}</pre>
                            </div>
                            <div class="col-md-6">
                                <strong>Expected Output:</strong>
                                <pre>{{ test_case.output|default:"No output" }}</pre>
                            </div>
                        </div>
                    </div>
                    {% empty %}
                    <div class="text-muted">No test cases provided.</div>
                    {% endfor %}
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.12/ace.js"></script>
<script src="{% static 'hackIDE/js/realtime-proctoring.js' %}"></script>
<script>
// Initialize Ace Editor
var editor = ace.edit("editor");
editor.setTheme("ace/theme/monokai");
editor.session.setMode("ace/mode/python");
editor.setOptions({
    enableBasicAutocompletion: true,
    enableLiveAutocompletion: true,
    enableSnippets: true
});

// Initialize Real-time Proctoring
let proctoring = null;
let proctoringInitialized = false;

function initializeProctoring() {
    if (proctoringInitialized) {
        console.log('Proctoring already initialized');
        return Promise.resolve(true);
    }
    
    const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]')?.value;
    if (!csrfToken) {
        console.error('CSRF token not found');
        showErrorMessage('Security token missing. Please refresh the page.');
        return Promise.resolve(false);
    }
    
    console.log('Creating RealtimeProctoring instance...');
    try {
        // Check if required browser APIs are available
        if (typeof window.RealtimeProctoring === 'undefined') {
            console.error('RealtimeProctoring class not found');
            showErrorMessage('Proctoring system not loaded properly. Please check browser compatibility.');
            return Promise.resolve(false);
        }
        
        proctoring = new RealtimeProctoring({{ contest.id }}, csrfToken);
    } catch (error) {
        console.error('Failed to create RealtimeProctoring instance:', error);
        showErrorMessage('Failed to initialize proctoring system. Please check browser compatibility.');
        return Promise.resolve(false);
    }
    
    // Set up event handlers
    if (proctoring) {
        proctoring.setOnWarning((data) => {
            console.log('Proctoring warning:', data);
            // Warning modal is handled automatically by the proctoring system
        });
        
        proctoring.setOnTermination((data) => {
            console.log('Contest terminated:', data);
            // Disable all form interactions
            document.getElementById('submit-solution').disabled = true;
            document.getElementById('test-code').disabled = true;
            editor.setReadOnly(true);
        });
        
        proctoring.setOnStatusUpdate((status) => {
            console.log('Proctoring status updated:', status);
            // Hide manual start button if proctoring starts successfully
            if (status === 'started') {
                const manualBtn = document.getElementById('manual-start-proctoring');
                if (manualBtn) {
                    manualBtn.style.display = 'none';
                }
            }
        });
    }
    
    // Start proctoring and return promise
    console.log('Starting proctoring...');
    if (proctoring) {
        return proctoring.start().then(success => {
            if (success !== false) {
                console.log('Proctoring started successfully');
                // Hide manual start button if proctoring starts successfully
                const manualBtn = document.getElementById('manual-start-proctoring');
                if (manualBtn) {
                    manualBtn.style.display = 'none';
                }
                proctoringInitialized = true;
                return true;
            } else {
                console.log('Automatic proctoring start failed, showing manual start button');
                // Show manual start button if automatic start fails
                const manualBtn = document.getElementById('manual-start-proctoring');
                if (manualBtn) {
                    manualBtn.style.display = 'inline-block';
                    manualBtn.onclick = function() {
                        console.log('Manual proctoring start requested');
                        return proctoring.start().then(result => {
                            if (result) {
                                manualBtn.style.display = 'none';
                                proctoringInitialized = true;
                            }
                            return result;
                        });
                    };
                }
                return false;
            }
        }).catch(error => {
            console.error('Failed to start proctoring:', error);
            showErrorMessage('Failed to start proctoring: ' + (error.message || 'Unknown error'));
            // Show manual start button
            const manualBtn = document.getElementById('manual-start-proctoring');
            if (manualBtn) {
                manualBtn.style.display = 'inline-block';
                manualBtn.onclick = function() {
                    console.log('Manual proctoring start requested');
                    return proctoring.start().then(result => {
                        if (result) {
                            manualBtn.style.display = 'none';
                            proctoringInitialized = true;
                        }
                        return result;
                    });
                };
            }
            return false;
        });
    } else {
        console.error('Proctoring instance not available');
        showErrorMessage('Proctoring system failed to initialize. Please check browser compatibility.');
        return Promise.resolve(false);
    }
}

// Helper function to show error messages
function showErrorMessage(message) {
    // Create or update error message element
    let errorElement = document.getElementById('proctoring-error');
    if (!errorElement) {
        errorElement = document.createElement('div');
        errorElement.id = 'proctoring-error';
        errorElement.style.cssText = `
            position: fixed;
            top: 100px;
            right: 20px;
            z-index: 10001;
            background: #dc3545;
            color: white;
            padding: 15px;
            border-radius: 5px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            font-size: 14px;
            max-width: 300px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        `;
        document.body.appendChild(errorElement);
    }
    
    errorElement.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: flex-start;">
            <div>
                <strong>Proctoring Error:</strong>
                <p style="margin: 5px 0 0 0; font-size: 13px;">${message}</p>
            </div>
            <button onclick="this.parentElement.parentElement.remove()" style="
                background: none;
                border: none;
                color: white;
                font-size: 18px;
                cursor: pointer;
                padding: 0;
                margin-left: 10px;
            ">&times;</button>
        </div>
    `;
    
    // Auto-hide after 10 seconds
    setTimeout(() => {
        if (errorElement && errorElement.parentElement) {
            errorElement.remove();
        }
    }, 10000);
}

// Start proctoring when page loads
document.addEventListener('DOMContentLoaded', function() {
    console.log('DOM loaded, checking proctoring requirements...');
    
    // Check if proctoring is required for this contest
    const requireProctor = {{ require_proctor|yesno:'true,false' }};
    const proctoringSkipReason = '{{ proctoring_skip_reason|default:'' }}';
    const isPracticeMode = {{ is_practice_mode|yesno:'true,false' }};
    
    console.log('Proctoring configuration:', {
        requireProctor,
        proctoringSkipReason,
        isPracticeMode
    });
    
    // Only initialize proctoring if it's actually required
    if (!requireProctor || isPracticeMode || proctoringSkipReason) {
        console.log('Proctoring not required - skipping initialization');
        console.log('Reason:', proctoringSkipReason || (isPracticeMode ? 'Practice mode' : 'Not required'));
        
        // Hide manual start button since proctoring is not needed
        const manualBtn = document.getElementById('manual-start-proctoring');
        if (manualBtn) {
            manualBtn.style.display = 'none';
        }
        
        return; // Exit early, don't initialize proctoring
    }
    
    console.log('Proctoring required, initializing system...');
    
    // Check if we're in practice mode
    if (isPracticeMode) {
        console.log('Practice mode detected, skipping proctoring initialization');
        // No proctoring needed in practice mode
        return;
    }
    
    // Check if we're on a contest problem page
    if (!window.location.pathname.includes('/contests/') || !window.location.pathname.includes('/problems/')) {
        console.log('Not on a contest problem page, skipping proctoring');
        return;
    }
    
    // Try to restore camera from GlobalCameraManager first
    if (window.contestCameraManager) {
        console.log('Attempting to restore camera from GlobalCameraManager...');
        
        if (window.contestCameraManager.isStreamActive()) {
            console.log('GlobalCameraManager has active stream, but checking if proctoring is still needed...');
            
            // Don't override the banner if proctoring is not required
            if (!requireProctor && proctoringSkipReason) {
                console.log('Proctoring no longer required due to:', proctoringSkipReason);
                // Stop the global camera manager since contest ended
                window.contestCameraManager.stop();
                return; // Keep the contest status banner
            }
            
            console.log('Proctoring still required, using GlobalCameraManager stream');
            
            // Update banner to show camera is active
            const banner = document.querySelector('.proctoring-banner');
            if (banner) {
                banner.innerHTML = `
                    <span class="banner-icon">üìπ</span>
                    <strong>Camera Monitoring Continued:</strong> Your camera stream has been maintained during navigation. 
                    Face must remain visible at all times.
                `;
                banner.style.background = 'linear-gradient(135deg, #28a745 0%, #20c997 100%)';
            }
            
            // Remove any transition message
            const transitionMessage = document.getElementById('camera-transition-message');
            if (transitionMessage) {
                transitionMessage.remove();
            }
            
            // Initialize proctoring with global manager's stream
            initializeProctoring();
            return;
        }
        
        // Try to restore state from storage
        const restored = window.contestCameraManager.restoreState();
        if (restored) {
            console.log('Successfully restored camera state, but checking if proctoring is still needed...');
            
            // Don't override the banner if proctoring is not required
            if (!requireProctor && proctoringSkipReason) {
                console.log('Proctoring no longer required due to:', proctoringSkipReason);
                // Stop the global camera manager since contest ended
                window.contestCameraManager.stop();
                return; // Keep the contest status banner
            }
            
            console.log('Proctoring still required, restoring camera state');
            
            // Update banner to show camera is active
            const banner = document.querySelector('.proctoring-banner');
            if (banner) {
                banner.innerHTML = `
                    <span class="banner-icon">üìπ</span>
                    <strong>Camera Monitoring Restored:</strong> Your camera monitoring has been restored. 
                    Face must remain visible at all times.
                `;
                banner.style.background = 'linear-gradient(135deg, #28a745 0%, #20c997 100%)';
            }
            
            // Initialize proctoring
            initializeProctoring();
            return;
        }
    }
    
    // Fallback to legacy detection methods
    const cameraVerified = sessionStorage.getItem('cameraVerified') === 'true';
    const navigationTime = sessionStorage.getItem('navigationTime');
    const isRecentNavigation = navigationTime && (Date.now() - parseInt(navigationTime)) < 30000;
    
    console.log('Camera state check:', {
        cameraVerified,
        isRecentNavigation,
        hasGlobalManager: !!window.contestCameraManager
    });
    
    if (cameraVerified || isRecentNavigation) {
        console.log('Camera was verified, but checking if proctoring is still needed...');
        
        // Don't override the banner if proctoring is not required
        if (!requireProctor && proctoringSkipReason) {
            console.log('Proctoring no longer required due to:', proctoringSkipReason);
            return; // Keep the contest status banner, don't override
        }
        
        console.log('Proctoring still required, attempting to restore proctoring...');
        
        // Update banner to show camera should be active
        const banner = document.querySelector('.proctoring-banner');
        if (banner) {
            banner.innerHTML = `
                <span class="banner-icon">üìπ</span>
                <strong>Camera Monitoring Active:</strong> Your camera continues monitoring you throughout this contest. 
                Face must remain visible at all times.
            `;
            banner.style.background = 'linear-gradient(135deg, #28a745 0%, #20c997 100%)';
        }
        
        // Initialize proctoring (will attempt to reuse existing streams)
        initializeProctoring();
        
    } else {
        console.log('Camera not yet verified, starting fresh proctoring');
        
        // Show manual start button for safety
        const manualBtn = document.getElementById('manual-start-proctoring');
        if (manualBtn) {
            manualBtn.style.display = 'inline-block';
            manualBtn.onclick = function() {
                console.log('Manual proctoring start requested');
                initializeProctoring();
            };
        }
        
        // Try automatic start with delay
        setTimeout(function() {
            console.log('Starting proctoring initialization...');
            initializeProctoring();
        }, 1500);
    }
});

// Track last auto-loaded boilerplate to decide safe replacement
let lastLoadedBoilerplate = '';

// Language change handler
function setEditorLanguage(language) {
    var mode = 'ace/mode/python';
    switch(language) {
        case 'JAVA': mode = 'ace/mode/java'; break;
        case 'CPP':
        case 'C': mode = 'ace/mode/c_cpp'; break;
        case 'JAVASCRIPT': mode = 'ace/mode/javascript'; break;
        case 'PYTHON':
        default: mode = 'ace/mode/python';
    }
    editor.session.setMode(mode);
}

const boilerplateMap = {{ boilerplate_map|default:"{}"|safe }};

function loadBoilerplate(language, forceReplace=false) {
    const bp = boilerplateMap[language] || boilerplateMap[language.toUpperCase()] || '';
    if (!bp) return;
    const current = editor.getValue();
    const shouldReplace = forceReplace || current.trim() === '' || current === lastLoadedBoilerplate;
    if (shouldReplace) {
        editor.setValue(bp, -1);
        lastLoadedBoilerplate = bp;
    }
}

// Initial setup
(function init() {
    const initialLang = document.getElementById('language').value;
    setEditorLanguage(initialLang);
    loadBoilerplate(initialLang, true);
})();

document.getElementById('language').addEventListener('change', function() {
    const language = this.value;
    setEditorLanguage(language);
    // Force replace on language change so the starting code updates
    loadBoilerplate(language, true);
});

// Test Code
document.getElementById('test-code').addEventListener('click', function() {
    // Check if contest is terminated
    if (proctoring && proctoring.isContestTerminated()) {
        showResult('Contest has been terminated. No further actions allowed.', 'error');
        return;
    }
    
    var sourceCode = editor.getValue();
    var language = document.getElementById('language').value;
    
    if (!sourceCode.trim()) {
        showResult('Please write some code before testing!', 'error');
        return;
    }
    
    testCode(sourceCode, language);
});

// Submit Solution
document.getElementById('submit-solution').addEventListener('click', function() {
    // Check if contest is terminated
    if (proctoring && proctoring.isContestTerminated()) {
        showResult('Contest has been terminated. No submissions allowed.', 'error');
        return;
    }
    
    var sourceCode = editor.getValue();
    var language = document.getElementById('language').value;
    
    if (!sourceCode.trim()) {
        showResult('Please write some code before submitting!', 'error');
        return;
    }
    
    submitSolution(sourceCode, language); // Submit solution
});

// Test code function for quick testing without submission
function testCode(sourceCode, language) {
    const testBtn = document.getElementById('test-code');
    const originalText = testBtn.innerHTML;
    
    // Disable button to prevent multiple tests
    testBtn.disabled = true;
    testBtn.innerHTML = '‚è≥ Testing...';
    
    // Use the existing compile/run endpoints for testing
    fetch('/compile/', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
        },
        body: `source=${encodeURIComponent(sourceCode)}&lang=${language}&input=`
    })
    .then(response => response.json())
    .then(data => {
        if (data.compile_status === 'OK') {
            showResult('‚úÖ Code compiled successfully! You can now submit your solution.', 'success');
            showTestResult({
                status: 'compiled',
                message: 'Compilation successful',
                output: data.run_status?.output || 'No output',
                execution_time: data.run_status?.time_used || '0',
                memory_used: data.run_status?.memory_used || '0'
            });
        } else {
            showResult('‚ùå Compilation failed. Please check your code.', 'error');
            showTestResult({
                status: 'compilation_error',
                message: 'Compilation failed',
                error: data.compile_status || 'Unknown compilation error'
            });
        }
    })
    .catch(error => {
        showResult('Error testing code: ' + error.message, 'error');
    })
    .finally(() => {
        // Re-enable button
        testBtn.disabled = false;
        testBtn.innerHTML = originalText;
    });
}

// Show test results (different from submission results)
function showTestResult(data) {
    var resultDiv = document.getElementById('submission-result');
    var details = '';
    
    if (data.status === 'compiled') {
        details = `
            <div class="alert alert-info">
                <h6>‚úÖ Code Test Successful!</h6>
                <p><strong>Compilation:</strong> Passed</p>
                <p><strong>Sample Output:</strong> <code>${data.output}</code></p>
                <p><strong>Execution Time:</strong> ${data.execution_time}ms</p>
                <p><strong>Memory Used:</strong> ${data.memory_used}KB</p>
                <small class="text-muted">üí° This is just a compilation test. Use "Submit Solution" to run against test cases.</small>
            </div>
        `;
    } else if (data.status === 'compilation_error') {
        details = `
            <div class="alert alert-danger">
                <h6>‚ùå Compilation Error</h6>
                <p><strong>Error:</strong> ${data.error}</p>
                <p><strong>Message:</strong> ${data.message}</p>
                <small class="text-muted">üí° Fix the compilation errors and try again.</small>
            </div>
        `;
    }
    
    resultDiv.innerHTML = details;
    resultDiv.style.display = 'block';
}

// Unified submit function
function submitSolution(sourceCode, language) {
    const submitBtn = document.getElementById('submit-solution');
    const originalText = submitBtn.innerHTML;
    
    // Disable button to prevent multiple submissions
    submitBtn.disabled = true;
    submitBtn.innerHTML = '‚è≥ Processing...';
    
    // Submit to your contest submission endpoint
    fetch(`/contests/{{ contest.id }}/problems/{{ problem.id }}/`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
        },
        body: `source_code=${encodeURIComponent(sourceCode)}&language=${language}&is_final=false`
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'accepted') {
            let message = `üéâ ${data.message}`;
            if (data.is_practice) {
                message += `\n${data.practice_message}`;
            }
            showResult(message, 'success');
            showDetailedResult(data);
        } else if (data.status === 'wrong_answer') {
            let message = `‚ùå ${data.message}`;
            if (data.is_practice) {
                message += `\n${data.practice_message}`;
            }
            showResult(message, 'error');
            showDetailedResult(data);
        } else if (data.status === 'runtime_error') {
            let message = `üí• ${data.message}`;
            if (data.is_practice) {
                message += `\n${data.practice_message}`;
            }
            showResult(message, 'error');
            showDetailedResult(data);
        } else {
            let message = 'Error: ' + data.message;
            if (data.is_practice) {
                message += `\n${data.practice_message}`;
            }
            showResult(message, 'error');
        }
    })
    .catch(error => {
        showResult('Error submitting solution: ' + error.message, 'error');
    })
    .finally(() => {
        // Re-enable button
        submitBtn.disabled = false;
        submitBtn.innerHTML = originalText;
    });
}

function showDetailedResult(data) {
    var resultDiv = document.getElementById('submission-result');
    var details = '';
    
    if (data.status === 'accepted') {
        details = `
            <div class="alert alert-success">
                <h6>‚úÖ Solution Accepted!</h6>
                <p><strong>Score:</strong> ${data.score} points</p>
                <p><strong>Execution Time:</strong> ${data.execution_time}ms</p>
                <p><strong>Memory Used:</strong> ${data.memory_used}KB</p>
            </div>
        `;
    } else if (data.status === 'wrong_answer') {
        details = `
            <div class="alert alert-warning">
                <h6>‚ùå Wrong Answer on Test Case ${data.test_case}</h6>
                <p><strong>Expected:</strong> <code>${data.expected}</code></p>
                <p><strong>Your Output:</strong> <code>${data.actual}</code></p>
                <p><strong>Progress:</strong> ${data.passed_tests}/${data.total_tests} test cases passed</p>
            </div>
        `;
    } else if (data.status === 'runtime_error') {
        details = `
            <div class="alert alert-danger">
                <h6>üí• Runtime Error</h6>
                <p><strong>Error:</strong> ${data.message}</p>
                <p><strong>Progress:</strong> ${data.passed_tests}/${data.total_tests} test cases passed</p>
            </div>
        `;
    }
    
    resultDiv.innerHTML = details;
    resultDiv.style.display = 'block';
}

function showResult(message, type) {
    var resultDiv = document.getElementById('submission-result');
    resultDiv.className = `submission-result ${type}`;
    resultDiv.innerHTML = message;
    resultDiv.style.display = 'block';
    
    // Auto-hide after 5 seconds
    setTimeout(() => {
        resultDiv.style.display = 'none';
    }, 5000);
}

// Handle page visibility change to pause/resume proctoring
document.addEventListener('visibilitychange', function() {
    if (proctoring) {
        if (document.hidden) {
            console.log('Page hidden - proctoring continues in background');
        } else {
            console.log('Page visible - proctoring active');
        }
    }
});

// Clean up proctoring when leaving the page
window.addEventListener('beforeunload', function() {
    if (proctoring) {
        proctoring.stop();
    }
});

// Back navigation function with camera preservation
function navigateBackToContest(event) {
    event.preventDefault();
    
    const contestUrl = `{% url 'hackIDE:contest_detail' contest.id %}`;
    
    console.log('Back navigation requested, preserving camera for:', contestUrl);
    
    // Use the same camera preservation logic as the "Solve Problem" button
    preserveCameraForNavigation(event, contestUrl);
}

// Enhanced camera preservation for navigation (reusable function)
function preserveCameraForNavigation(event, targetUrl) {
    event.preventDefault();
    
    console.log('Preserving camera for navigation to:', targetUrl);
    
    // Set server-side session to maintain camera verification
    fetch('{% url 'hackIDE:contest_detail' contest.id %}', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            'X-CSRFToken': '{{ csrf_token }}'
        },
        body: 'action=set_camera_verified&contest_id={{ contest.id }}'
    });
    
    // Use GlobalCameraManager for robust camera preservation
    if (window.contestCameraManager && window.contestCameraManager.isStreamActive()) {
        console.log('Using GlobalCameraManager for navigation preservation');
        
        // GlobalCameraManager will handle stream preservation automatically
        window.contestCameraManager.prepareForNavigation();
        
        // Show loading message
        const loadingMessage = document.createElement('div');
        loadingMessage.id = 'camera-transition-message';
        loadingMessage.innerHTML = `
            <div style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); 
                        background: rgba(0,0,0,0.8); color: white; padding: 20px; border-radius: 10px; 
                        z-index: 10000; text-align: center;">
                <div style="margin-bottom: 10px;">üìπ Maintaining Camera Stream</div>
                <div style="font-size: 14px; opacity: 0.8;">Navigating back to contest...</div>
            </div>
        `;
        document.body.appendChild(loadingMessage);
        
        // Navigate after a short delay
        setTimeout(() => {
            window.location.href = targetUrl;
        }, 500);
        
    } else {
        // Fallback: use session storage for camera state
        console.log('No active camera stream, using fallback navigation');
        
        const cameraVerified = sessionStorage.getItem('cameraVerified') === 'true';
        if (cameraVerified) {
            sessionStorage.setItem('cameraVerified', 'true');
            sessionStorage.setItem('contestId', '{{ contest.id }}');
            sessionStorage.setItem('navigationTime', Date.now().toString());
        }
        
        window.location.href = targetUrl;
    }
}
</script>
{% endblock %}